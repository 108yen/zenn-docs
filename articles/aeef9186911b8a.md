---
title: '`"use cache"`の動作検証'
emoji: "🕐"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["vercel", "nextjs"]
published: true
---

# はじめに

Next.js v15 のアプリケーションを Next.js v16 移行しようと思ったところ、Vercel 上での`"use cache"`の動作について検証する必要が出てきたので、この記事はそのついでで書いています。

:::details 経緯
ビルド時にはデータフェッチして欲しくないけど、アクセスが来たらデータフェッチ後、一定期間キャッシュしておいてほしいため、`unstable_cache`を使用していました。が、Next.js v16 に上げたところ動作が変わっていたので、ちゃんと`"use cache"`を使うことにしました。
:::

`"use cache"`の動作を公式のドキュメントだけで理解するには不足している点も多く、その部分については以下のような issue で議論もされています。特に一つ目の issue の[こちらのコメント](https://github.com/vercel/next.js/issues/85240#issuecomment-3560124078)は理解の助けになりました。今回はこれらのコメントと照らし合わせながら、Vercel 上で`"use cache"`の動作確認を実施していますが、もしこの記事と矛盾している内容がある場合は、issue で議論されている方が正になりますのでご容赦ください。

https://github.com/vercel/next.js/issues/85240
https://github.com/vercel/next.js/issues/86686
https://github.com/vercel/next.js/issues/86760

また、検証アプリを作っていますが、他の人がキャッシュをパージした場合正確な動作の確認はできなくなるので、ちゃんと確認したい方は自分の環境にデプロイしてください。

- [検証アプリ](https://cache-test-silk.vercel.app/)
- [コード](https://github.com/108yen/cache-test)

# `"use cache"`概要

まず、`"use cache"`とはどんなものだったかの振り返りをしたいと思います。ここはすでに語り尽くされた内容なので、知っている方は飛ばすか流し読みしてください。

`"use cache"`の機能を使用したい場合、Next.js のモードを切り替える必要があります。モードの切り替えは簡単で、Next.js のコンフィグに`cacheComponents: true`を追記するだけです。

```ts:next.config.ts
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  // 追加
  cacheComponents: true,
};

export default nextConfig;
```

`cacheComponents: true`にすると、これまでのページ生成方法の`Static/Dynamic`指定方法が変わります。各ページはデフォルトで`Partial Prerender`となり、ページ上部に`"use cache"`を記載したときにそのページは`Static`になります。[Dynamic Route](https://nextjs.org/docs/app/api-reference/file-conventions/dynamic-routes)にしている場合や[Dynamic API](https://nextjs.org/docs/app/guides/caching#dynamic-rendering)を使用している場合は、`Partial Prerender`です。アクセスが来たタイミングでしかわからないパラメータを使用してページを生成する必要があるので当然ですね。

:::message
特に[Dynamic API](https://nextjs.org/docs/app/guides/caching#dynamic-rendering)を使用していると動的なページ生成になるというのは見落としがち。
:::

環境変数に`NEXT_PRIVATE_DEBUG_CACHE=1`を設定すると、キャッシュのログを出すことができます。

### Static

`"use cache"`をトップに記載したページやコンポーネントは`Static`としてビルド時にレンダリングされますが、キャッシュをパージすると再生成されるので、ディレクティブの名称通り静的なページになるというよりは"キャッシュされる"という理解の方が近いと思っています。
[static/cached](https://cache-test-silk.vercel.app/static/cached)

:::details ビルドログの例

```sh
Route (app)                    Revalidate  Expire
┌ ○ /
├ ○ /_not-found
├ ◐ /dynamic/component/[slug]
│ └ /dynamic/component/[slug]
├ ◐ /dynamic/data/[slug]
│ └ /dynamic/data/[slug]
├ ○ /static/cached                    15m      1y
└ ◐ /static/uncached                  15m      1y


○  (Static)             prerendered as static content
◐  (Partial Prerender)  prerendered as static HTML with dynamic server-streamed content
```

:::

もし、動的にレンダリングしたい部位があり、無理やり`Suspense`で囲っても意味がありません。問答無用でビルド時にレンダリングされます。

### Partial Prerender

まず、`Partial Prerender`とは何か、ですがページ自体は動的に生成され、その中の各要素やデータごとにさらに`Static/Partial Prerender`を指定できるようになります。
[static/uncached](https://cache-test-silk.vercel.app/static/uncached)

:::details 例

- [検証アプリ](https://cache-test-silk.vercel.app/static/uncached)
- [page.tsx](https://github.com/108yen/cache-test/blob/main/src/app/static/uncached/page.tsx)
- [component.tsx](https://github.com/108yen/cache-test/blob/main/src/cached/component.tsx)

例えば以下の`page.tsx`は`"use cache"`を記載していないので、`Partial Prerender`なページとなり、このページ自体は動的にリクエストごとにレンダリングがされます。`Cached`および`CachedRemote`はそれぞれのコンポーネント内で`"use cache"`を記載しているため、この部分はキャッシュされますが、`Uncached`コンポーネントはキャッシュされないので、リクストごとに動的に生成されます。動的なコンポーネントはレンダリング中のフォールバックを明記するために`Suspense`で囲う必要があります。

```tsx:page.tsx
export default async function Page() {
  return (
    <PageLayout>
      <Cached />

      <CachedRemote />

      <Suspense fallback={<LoadingCard />}>
        <Uncached />
      </Suspense>
    </PageLayout>
  );
}
```

```tsx:component.tsx
interface Props {
  params?: Promise<{ slug: string }>
}

export async function Cached({ params }: Props) {
  "use cache"

  const { slug } = params ? await params : {}
  cacheTag(`cached-component-${slug}`, "component", "all")

  await wait(5)
  const date = new Date()

  return (
    ...
  )
}

export async function CachedRemote({ params }: Props) {
  "use cache: remote"

  const { slug } = params ? await params : {}
  cacheTag(`cached-remote-component-${slug}`, "component", "all")

  await wait(5)
  const date = new Date()

  return (
    ...
  )
}

export async function Uncached({ params }: Props) {
  const { slug } = params ? await params : {}

  await wait(5)
  const date = new Date()

  return (
    ...
  )
}
```

:::

### まとめ

簡単にまとめると、`cacheComponents: true`でモードを切り替えた場合以下のようになります。

- 全てのコンポーネントはキャッシュされるか、動的に生成されるかのいずれかになる。(デフォルトは動的)
  - キャッシュされるコンポーネントはビルド時に事前レンダリングされる。
  - 動的に生成されるコンポーネントは`Suspense`で囲う必要がある。
- `Partial Prerender`内の要素はさらにその要素ごとにキャッシュするか動的に生成するかを選べる。

# Dynamic Routing

ここからが本記事の本題となります。上記にまとめた理解で Dynamic Routing におけるコンポーネントのキャッシュをしたい場合、以下のようにすればパラメータを渡さなかった方はキャッシュされます。

```tsx:/dynamic/component/[slug]/page.tsx
export default async function Page({
  params,
}: PageProps<"/dynamic/component/[slug]">) {
  return (
    <PageLayout>
      {/* paramsを渡さない場合 */}
      <Cached />

      {/* paramsをわたす場合 */}
      <Suspense fallback={<LoadingCard />}>
        <Cached params={params} />
      </Suspense>
    </PageLayout>
  )
}

interface Props {
  params?: Promise<{ slug: string }>
}

async function Cached({ params }: Props) {
  "use cache"

  const { slug } = params ? await params : {}

  return (
    ...
  )
}

```

結果も予想通り、`params`を渡していないコンポーネントはキャッシュできているため即座にレンダリングされますが、`params`を渡したコンポーネントは毎回レンダリングが走っています。
[dynamic/component/cache/1](https://cache-test-silk.vercel.app/dynamic/component/cache/1)

![dynamic page in cache](/images/aeef9186911b8a/cache.gif)

では、[Dynamic API](https://nextjs.org/docs/app/guides/caching#dynamic-rendering)を使用したレンダリング結果やデータをキャッシュしたい場合はどうすれば良いのでしょうか？ビルド時のレンダリングではパラメータが不明もしくはレンダリングさせたくないが、一度アクセスがあったらその結果をキャッシュしておいて欲しい。そんなユースケースもあると思います。この場合、`"use cache:remote"`を使用することになります。

## `"use cache: remote"`

まずは結果から見てみましょう。`"use cache"`を追記したコンポーネントは先ほどと同様に毎回レンダリングされていますが、`"use cache: remote"`を追記したコンポーネントは想定通りキャッシュされています。
[dynamic/component/1](https://cache-test-silk.vercel.app/dynamic/component/1)

![dynamic page in cache remote](/images/aeef9186911b8a/cache-remote.gif)

`"use cache: remote"`について、[ドキュメント](https://nextjs.org/docs/app/api-reference/directives/use-cache-remote)を読むと以下のように書かれています。

> The 'use cache: remote' directive lets you declaratively specify that a cached output should be stored in a remote cache instead of in-memory. While this gives you more durable caching for specific operations, it comes with tradeoffs: infrastructure cost and network latency during cache lookups.

`"use cache: remote"`を使用すると、メモリ内ではなくリモートにキャッシュされるということらしいです。読み進めていくと、[ここ](https://nextjs.org/docs/app/api-reference/directives/use-cache-remote#when-remote-caching-makes-sense)でどういう時に使えば良いのかも書かれています。

> Remote caching provides the most value when content is deferred to request time (outside the static shell). This typically happens when a component accesses request values like `cookies()`, `headers()`, or searchParams, placing it inside a Suspense boundary.

リクエスト時にコンテンツをキャッシュしたい場合に最も効力を発揮する、つまりやりたいことドンビシャです。

:::message
たまに`static shell`という用語が出てきます。これはおそらく動的なパラメータを使用せず、ビルド時に生成可能（pre-rendering 可能）なコンポーネント、もしくはその領域を指していると思われます。
:::

:::details `await`の場所

Dynamic Routing の`params`やその他の[Dynamic API](https://nextjs.org/docs/app/guides/caching#dynamic-rendering)から値を取ってレンダリングした結果をキャッシュしたい場合、`await`の位置に少し悩みます。具体的にいうと、以下の 2 パターンになります。

- 全体を`Suspense`で囲い、キャッシュするコンポーネントに対して`Promise`を解除して渡す
- `Promise`のまま渡し、コンポーネント内で解除する

[ドキュメントの例](https://nextjs.org/docs/app/api-reference/directives/use-cache-remote#caching-with-runtime-data)では`Suspense`内のコンポーネントのトップで`Promise`を解除した上でキャッシュするコンポーネントに値を渡しているのですが、この構成だとページ全体のレンダリングが完了するまで待つので、部分的にレンダリングする`Partial Prerender`の良さを活かしきれていません。
[dynamic/component/awaited/1](https://cache-test-silk.vercel.app/dynamic/component/awaited/1)

![suspended cache components](/images/aeef9186911b8a/suspense.gif)
このパターンで実装する場合はキャッシュするコンポーネントを囲う`Suspense`内で`Promise`を解除するようにしましょう。

```tsx
<Suspense fallback={<LoadingCard />}>
  {params.then(({ slug }) => (
    <Cached slug={slug} />
  ))}
</Suspense>
```

対して`Promise`のままコンポーネントに`params`を渡し、コンポーネント内で`const ... = await params`で値を取り出せばコンポーネントごとにフォールバックしてくれるし、ページ全体を`Suspense`で囲う必要もなくなるので、こちらの方が良いと思います。
[dynamic/component/1](https://cache-test-silk.vercel.app/dynamic/component/1)

![dynamic page in cache remote](/images/aeef9186911b8a/cache-remote.gif)
:::

## `"use cache"`と`"use cache: remote"`の違い

では`"use cache"`と`"use cache: remote"`は何が違うのでしょうか？この部分について、[こちらのコメント](https://github.com/vercel/next.js/issues/85240#issuecomment-3560124078)が非常に参考になりました。

ここからはコメントの解説になります。
まず、前提としてデプロイする環境によって`"use cache"`, `"use cache: remote"`の動作は異なるようです。
デフォルトでは、`"use cache"`, `"use cache: remote"`ともにメモリをストレージとしてキャッシュします。これによりビルドしてローカルで`next start`を実行した際にはどちらも同じ動作になるはずです。

:::details ローカル実行

ローカルでビルド、実行し Vercel 上にデプロイした[dynamic/component/1](https://cache-test-silk.vercel.app/dynamic/component/1)と同じページを見てみましょう。Vercel 上にデプロイした場合は`"use cache"`を付加したコンポーネントはキャッシュされませんでしたが、想定通り、`"use cache"`, `"use cache:remote"`ともにキャッシュされ同じ動作になっています。

![local](/images/aeef9186911b8a/local.gif)

:::

サードパーティのホストプロバイダーは`"use cache"`, `"use cache: remote"`それぞれの動作をカスタマイズすることができ、プラットフォームに統合されたキャッシュ動作を提供できます。そして Vercel も例外ではなくカスタマイズされています。新しく`"use cache: xxx"`のようなディレクティブも作成可能なようです。
Vercel はサーバーレス環境のため、はじめのアクセスでメモリ内にデータを保管したとしても、2 回目以降はまた別のサーバーで実行されるため、そのデータを参照することができません。したがって、メモリ内キャッシュが意味をなしません。
このため Vercel 上のアプリケーションは何もメモリにはキャッシュしません。
`"use cache"`はあくまでその要素が pre-rendering 可能かどうか、prefetch して即時ナビゲーションが可能かどうかの検出をするために使用されます。
`"use cache: remote"`が付与された要素は外部のストレージにキャッシュされ、各サーバーレス環境から参照されます。これにより Dynamic Routing 内の要素でもキャッシュ可能となります。

以上が Vercel 上で Dynamic Routing 内の要素においては`"use cache"`が要素をキャッシュせず、`"use cache: remote"`でキャッシュ可能となる理由です。ちなみに`"use cache: remote"`は費用がかかると記載されていますが、Vercel の hobby プランで動かしている検証アプリでキャッシュが効いているので、いくらか利用可能なようです。どの使用量が関係しているのかはあまりわかっていませんが、ISR Write/Read とか？な気がしています。

# まとめ

今回は Vercel 上での動作確認となりますので、他の環境で動かす際には検証の上、利用するのが良いと思います。[検証アプリ](https://github.com/108yen/cache-test)に大体のパターンは実装しているので、自由に使ってください。

また、自分は使う必要がなかったので特に調査していませんが、`"use cache: private"`というクライアント側にキャッシュを持たせるような機能もあります。これもいつか誰かが解説してくれるでしょう。
